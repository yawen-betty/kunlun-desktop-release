import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

// This script scans the local filesystem for bundles and generates a latest.json.
// It assumes that artifacts from all platforms have been downloaded to the expected directory structure.

interface FileInfo {
  signature: string;
  size: number;
}

interface PlatformInfo {
  signature: string;
  url: string;
  size: number;
}

interface LatestJson {
  version: string;
  notes: string;
  pub_date: string;
  platforms: {
    [key: string]: PlatformInfo;
  };
}

class LatestGenerator {
  private encoding: BufferEncoding = 'utf-8';
  private package: any;
  private bundlePath: string;
  private downloadUrl: string;

  constructor() {
    const packageData = fs.readFileSync('package.json', { encoding: this.encoding });
    this.package = JSON.parse(packageData);
    this.bundlePath = path.join('src-tauri', 'target', 'release', 'bundle');

    // Construct a base URL for downloads. This part is tricky without the live request context.
    // We will assume a generic structure based on the repo and tag.
    const repo = process.env.GITHUB_REPOSITORY || 'owner/repo';
    const tag = process.env.RELEASE_TAG || 'v0.0.0';
    this.downloadUrl = `https://github.com/${repo}/releases/download/${tag}`;
  }

  private getFileInfo(filePath: string): FileInfo | null {
    if (!fs.existsSync(filePath)) {
      return null;
    }
    const buffer = fs.readFileSync(filePath);
    const sigFilePath = `${filePath}.sig`;
    if (!fs.existsSync(sigFilePath)) {
      console.warn(`Signature file not found for: ${filePath}`);
      return null; // Return null if signature is missing
    }
    const signatureBuffer = fs.readFileSync(sigFilePath);
    return {
      signature: signatureBuffer.toString().trim(),
      size: buffer.length,
    };
  }

  private findPlatformFiles() {
    const platforms: { [key: string]: PlatformInfo } = {};
    const bundleDir = this.bundlePath;

    if (!fs.existsSync(bundleDir)) {
      console.warn(`Bundle directory not found: ${bundleDir}`);
      return platforms;
    }

    // macOS: Prioritize .app.tar.gz for updater
    const macosAppTar = path.join(bundleDir, 'macos', `Kunlun.app.tar.gz`);
    const appTarInfo = this.getFileInfo(macosAppTar);
    if (appTarInfo) {
        platforms['darwin-x86_64'] = { ...appTarInfo, url: `${this.downloadUrl}/${path.basename(macosAppTar)}` };
    }

    // Windows
    const windowsMsi = path.join(bundleDir, 'msi', `Kunlun_${this.package.version}_x64_en-US.msi`);
    const winInfo = this.getFileInfo(windowsMsi);
    if (winInfo) {
      platforms['windows-x86_64'] = { ...winInfo, url: `${this.downloadUrl}/${path.basename(windowsMsi)}` };
    }

    // Linux
    const linuxAppImage = path.join(bundleDir, 'appimage', `kunlun_${this.package.version}_amd64.AppImage`);
    const appImageInfo = this.getFileInfo(linuxAppImage);
    if (appImageInfo) {
      platforms['linux-x86_64'] = { ...appImageInfo, url: `${this.downloadUrl}/${path.basename(linuxAppImage)}` };
    }

    return platforms;
  }

  public generate() {
    console.log('Scanning for bundles in:', this.bundlePath);
    const platforms = this.findPlatformFiles();

    if (Object.keys(platforms).length === 0) {
      console.error('No platform files found after scanning all potential paths.');
      return;
    }

    const latestJson: LatestJson = {
      version: this.package.version,
      notes: "Generated by CI.",
      pub_date: new Date().toISOString(),
      platforms,
    };

    const outputPath = path.join('latest.json');
    fs.writeFileSync(outputPath, JSON.stringify(latestJson, null, 2), this.encoding);

    console.log('Successfully generated latest.json at:', outputPath);
    console.log('Content:', JSON.stringify(latestJson, null, 2));
  }
}

const generator = new LatestGenerator();
generator.generate();
